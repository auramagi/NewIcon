import Foundation
import SwiftUI
import UniformTypeIdentifiers

enum PreviewData {
    enum Icon {
        case bestRepresentation(ofType: UTType)
        
        var image: NSImage {
            switch self {
            case let .bestRepresentation(type):
                let sampleIcon = NSWorkspace.shared.icon(for: type)
                guard let bestRepresentation = sampleIcon.bestRepresentation(for: .infinite, context: nil, hints: [:]) else {
                    return sampleIcon
                }
                
                let result = NSImage()
                result.addRepresentation(bestRepresentation)
                return result
            }
        }
        
        static var appIcon: Self { .bestRepresentation(ofType: .applicationBundle) }
        
        static var folder: Self { .bestRepresentation(ofType: .folder) }
    }
    
    static let text = "Hello world"
}

public protocol _ImageTemplate {
    init(image: NSImage, data: Data?) throws
    
    var asAnyView: AnyView { get }
}

public protocol ImageTemplate: View, _ImageTemplate {
    associatedtype Content
    
    init(image: NSImage)
    
    init(image: NSImage, content: Content)
    
    static func makePreview(image: NSImage) -> Self
}

public extension ImageTemplate where Content: Decodable {
    static var decoder: JSONDecoder {
        let decoder = JSONDecoder()
        decoder.allowsJSON5 = true
        return decoder
    }
    
    init(image: NSImage) {
        fatalError("Template expects non-nil content.")
    }
    
    init(image: NSImage, data: Data?) throws {
        guard let data = data else { throw "Template expects non-nil content." }
        let content = try Self.decoder.decode(Content.self, from: data)
        self.init(image: image, content: content)
    }
    
    init<T>(image: NSImage, data: Data?) throws where Content == T? {
        let content: Content
        if let data = data {
            content = try Self.decoder.decode(Content.self, from: data)
        } else {
            content = nil
        }
        self.init(image: image, content: content)
    }
}

public extension ImageTemplate where Content == Never {
    init(image: NSImage, data: Data?) throws {
        guard data == nil else { throw "Template expects content to be nil." }
        self.init(image: image)
    }
    
    init(image: NSImage, content: Content) {
        fatalError("How did you get here?")
    }
}

extension ImageTemplate {
    public var asAnyView: AnyView {
        AnyView(self)
    }
    
    static func makePreview(icon: PreviewData.Icon) -> Self {
        makePreview(image: icon.image)
    }
}

internal extension ImageTemplate {
    @ViewBuilder static func makeDefaultPreviews(factory: (PreviewData.Icon) -> Self) -> some View {
        Group {
            factory(.appIcon)
                .previewDisplayName("App icon")
            
            factory(.folder)
                .previewDisplayName("Folder")
        }
        .frame(width: 1024, height: 1024)
        .colorScheme(.light)
        .ignoresSafeArea()
        .drawingGroup()
        .previewLayout(.sizeThatFits)
    }
}

public extension ImageTemplate where Content == String {
    static func makePreview(image: NSImage) -> Self {
        .init(image: image, content: PreviewData.text)
    }
}

public extension ImageTemplate where Content == String? {
    static func makePreview(image: NSImage) -> Self {
        .init(image: image, content: PreviewData.text)
    }
}

public extension ImageTemplate where Content == Never {
    static func makePreview(image: NSImage) -> Self {
        .init(image: image)
    }
}

public extension ImageTemplate where Self: PreviewProvider {
    static var previews: some View {
        makeDefaultPreviews(factory: makePreview(icon:))
    }
}

extension String: Error { }

@_cdecl("isImageTemplate")
public func isImageTemplate(type: Any) -> Bool {
    type as? _ImageTemplate.Type != nil
}

@_cdecl("renderImageTemplate")
public func renderTemplate(type: Any, content: Any) -> Any {
    var result: Result<AnyView, Error>
    do {
        guard let (image, data) = content as? (NSImage, Data?) else { throw "Incorrect renderTemplate arguments" }
        guard let resolvedType = type as? _ImageTemplate.Type else { throw "Incorrect template type \(type)" }
        result = .success(try resolvedType.init(image: image, data: data).asAnyView)
    } catch {
        result = .failure(error)
    }
    return result
}
